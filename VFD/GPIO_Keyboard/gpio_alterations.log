- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./main.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//===============================
// FILE: main.c
//===============================
#include "vfd_display.h"
#include "vfd_keyboard.h"
#include "vfd_gpio.h"
#include <errno.h>
#include <signal.h>

VFD_Display* vfd = NULL;
GPIO_Control* gpio = NULL;

void cleanup(int signum) {
    if (vfd) vfd_close(vfd);
    if (gpio) gpio_cleanup(gpio);
    keyboard_restore();
    exit(signum);
}

int main() {
    // Set up signal handlers
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // Initialize VFD
    vfd = vfd_init("/dev/ttyUSB0");
    if (!vfd) {
        fprintf(stderr, "Failed to initialize VFD display: %s\n", strerror(errno));
        return 1;
    }

    // Initialize GPIO and NeoPixel
    gpio = gpio_init();
    if (!gpio) {
        fprintf(stderr, "Failed to initialize GPIO control\n");
        cleanup(1);
        return 1;
    }

    // Clear display and prepare keyboard
    vfd_clear(vfd);
    keyboard_raw_mode();

    // Show initial mode
    show_mode_instructions(vfd, gpio->current_mode);
    update_neopixel_mode(gpio);

    // Main loop
    while (1) {
        // Check for mode changes
        if (gpio->mode_changed) {
            gpio->mode_changed = 0;
            show_mode_instructions(vfd, gpio->current_mode);
            continue;
        }

        // Handle input based on current mode
        switch (gpio->current_mode) {
            case MODE_SSH:
            case MODE_LOCAL_KB: {
                int c = read_key();
                if (c < 0) continue;

                // Handle special keys
                switch (c) {
                    case 1001:  // Up arrow
                        write(vfd->fd, VFD_CURSOR_UP, 2);
                        break;

                    case 1002:  // Down arrow
                        write(vfd->fd, VFD_NEWLINE, 2);
                        break;

                    case 1003:  // Right arrow
                        write(vfd->fd, "\x09", 1);
                        break;

                    case 1004:  // Left arrow
                        write(vfd->fd, "\x08", 1);
                        break;

                    case 1005:  // Delete
                        write(vfd->fd, "\x19\x10", 2);
                        break;

                    case 127:   // Backspace
                    case 8:     // Also handle Ctrl-H backspace
                        write(vfd->fd, "\x08", 1);
                        write(vfd->fd, "\x19\x10", 2);
                        break;

                    case 13:    // Enter
                        write(vfd->fd, VFD_NEWLINE, 2);
                        break;

                    default:
                        // Regular printable character
                        if (c >= 32 && c <= 126) {
                            write(vfd->fd, &c, 1);
                        }
                        break;
                }
                break;
            }

            case MODE_AUTO:
                // In auto mode, could read from a file or message queue
                // For now, just show a simple message
                vfd_write(vfd, "Auto mode active... \n");
                sleep(2);
                break;
        }
    }

    cleanup(0);
    return 0;
}




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./main_for_console.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include "vfd_display.h"
#include "vfd_keyboard.h"
#include "vfd_mode_switch.h"
#include <errno.h>
#include <signal.h>
#include <ctype.h>

VFD_Display* vfd = NULL;
Mode_Control* mode_ctrl = NULL;

void cleanup(int signum) {
    if (vfd) vfd_close(vfd);
    if (mode_ctrl) mode_cleanup(mode_ctrl);
    keyboard_restore();
    exit(signum);
}

// Function to print console menu
void print_console_menu() {
    printf("\nVFD Input Control Menu:\n");
    printf("Commands:\n");
    printf("  ssh  - Switch to SSH keyboard input\n");
    printf("  raw  - Switch to raw keyboard input\n");
    printf("  mode - Show current mode\n");
    printf("  quit - Exit program\n");
    printf("Current mode: %s\n", get_mode_name(mode_ctrl->current_mode));
    printf("\nEnter command> ");
    fflush(stdout);
}

// Function to process console commands
void process_command(const char* cmd) {
    // Convert command to lowercase
    char lcmd[32] = {0};
    int i;
    for(i = 0; cmd[i] && i < 31; i++) {
        lcmd[i] = tolower(cmd[i]);
    }
    lcmd[i] = '\0';

    if (strcmp(lcmd, "ssh") == 0) {
        mode_ctrl->current_mode = MODE_SSH;
        show_mode_instructions(vfd, mode_ctrl->current_mode);
        printf("Switched to SSH keyboard input mode\n");
    }
    else if (strcmp(lcmd, "raw") == 0) {
        mode_ctrl->current_mode = MODE_LOCAL_KB;
        show_mode_instructions(vfd, mode_ctrl->current_mode);
        printf("Switched to raw keyboard input mode\n");
    }
    else if (strcmp(lcmd, "mode") == 0) {
        printf("Current mode: %s\n", get_mode_name(mode_ctrl->current_mode));
    }
    else if (strcmp(lcmd, "quit") == 0 || strcmp(lcmd, "exit") == 0) {
        cleanup(0);
    }
    else {
        printf("Unknown command. Available commands: ssh, raw, mode, quit\n");
    }
}

int main() {
    // Set up signal handlers
    signal(SIGINT, cleanup);
    signal(SIGTERM, cleanup);

    // Initialize VFD
    vfd = vfd_init("/dev/ttyUSB0");
    if (!vfd) {
        fprintf(stderr, "Failed to initialize VFD display: %s\n", strerror(errno));
        return 1;
    }

    // Initialize mode control
    mode_ctrl = mode_init();
    if (!mode_ctrl) {
        fprintf(stderr, "Failed to initialize mode control\n");
        cleanup(1);
        return 1;
    }

    // Clear display
    vfd_clear(vfd);
    
    // Show initial mode
    show_mode_instructions(vfd, mode_ctrl->current_mode);

    // Print initial console menu
    print_console_menu();

    // Main command loop
    char cmd[32];
    while (fgets(cmd, sizeof(cmd), stdin)) {
        // Remove newline
        cmd[strcspn(cmd, "\n")] = 0;
        
        // Process the command
        process_command(cmd);
        
        // Show menu again
        print_console_menu();
    }

    cleanup(0);
    return 0;
}



- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_decoder.h
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//===============================
// FILE: vfd_decoder.h
//===============================
#ifndef VFD_DECODER_H
#define VFD_DECODER_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Convert VFD response to human readable format with ASCII names
char* vfd_decode_response(const char* response) {
    if (!response) return NULL;

    // Allocate buffer - each byte could become up to 5 chars (#XXX)
    // plus room for null terminator
    size_t max_len = strlen(response) * 5 + 1;
    char* decoded = malloc(max_len);
    if (!decoded) return NULL;

    size_t pos = 0;

    for (int i = 0; response[i] != '\0'; i++) {
        unsigned char c = (unsigned char)response[i];

        switch(c) {
            case 0x02:
                pos += sprintf(decoded + pos, "#STX");
                break;
            case 0x03:
                pos += sprintf(decoded + pos, "#ETX");
                break;
            case 0x04:
                pos += sprintf(decoded + pos, "#EOT");
                break;
            case 0x00:
                pos += sprintf(decoded + pos, "#NUL");
                break;
            case 0x07:
                pos += sprintf(decoded + pos, "#BEL");
                break;
            case 0x08:
                pos += sprintf(decoded + pos, "#BS");
                break;
            case 0x09:
                pos += sprintf(decoded + pos, "#HT");
                break;
            case 0x0A:
                pos += sprintf(decoded + pos, "#LF");
                break;
            case 0x0B:
                pos += sprintf(decoded + pos, "#VT");
                break;
            case 0x0C:
                pos += sprintf(decoded + pos, "#FF");
                break;
            case 0x0D:
                pos += sprintf(decoded + pos, "#CR");
                break;
            case 0x0E:
                pos += sprintf(decoded + pos, "#SO");
                break;
            case 0x0F:
                pos += sprintf(decoded + pos, "#SI");
                break;
            case 0x10:
                pos += sprintf(decoded + pos, "#DLE");
                break;
            case 0x19:
                pos += sprintf(decoded + pos, "#EM");
                break;
            default:
                // If it's a printable character, just copy it
                if (c >= 0x20 && c <= 0x7E) {
                    decoded[pos++] = c;
                } else {
                    // Otherwise show hex
                    pos += sprintf(decoded + pos,pos += sprintf(decoded + pos, "#%02X", c);
                }
        }
    }

    decoded[pos] = '\0';
    return decoded;
}

#endif




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_display.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//===============================
// FILE: vfd_display.c
//===============================
#include "vfd_display.h"

VFD_Display* vfd_init(const char* port) {
    VFD_Display* vfd = malloc(sizeof(VFD_Display));
    if (!vfd) return NULL;

    // Open port with specific flags
    vfd->fd = open(port, O_RDWR | O_NOCTTY | O_NDELAY);
    if (vfd->fd < 0) {
        free(vfd);
        return NULL;
    }

    // Get current settings
    tcgetattr(vfd->fd, &vfd->old_tio);
    memset(&vfd->new_tio, 0, sizeof(struct termios));

    // Configure port settings (7E1)
    // Clear all flags first
    vfd->new_tio.c_cflag = 0;
    vfd->new_tio.c_iflag = 0;
    vfd->new_tio.c_oflag = 0;
    vfd->new_tio.c_lflag = 0;

    // Set the exact flags we need
    vfd->new_tio.c_cflag = CS7 | PARENB | CREAD | CLOCAL;
    vfd->new_tio.c_cc[VMIN] = 0;  // Non-blocking read
    vfd->new_tio.c_cc[VTIME] = 10; // 1 second timeout

    // Set baud rate
    cfsetispeed(&vfd->new_tio, B9600);
    cfsetospeed(&vfd->new_tio, B9600);

    // Flush port and apply settings
    tcflush(vfd->fd, TCIOFLUSH);
    tcsetattr(vfd->fd, TCSANOW, &vfd->new_tio);

    // Enable RTS explicitly
    int flags;
    if (ioctl(vfd->fd, TIOCMGET, &flags) != -1) {
        flags |= TIOCM_RTS;
        ioctl(vfd->fd, TIOCMSET, &flags);
    }

    // Wait for display to stabilize
    usleep(100000);  // 100ms delay

    vfd->current_row = 0;
    vfd->current_col = 0;

    return vfd;
}

void vfd_close(VFD_Display* vfd) {
    if (!vfd) return;
    tcsetattr(vfd->fd, TCSANOW, &vfd->old_tio);
    close(vfd->fd);
    free(vfd);
}

void vfd_clear(VFD_Display* vfd) {
    if (!vfd) return;
    write(vfd->fd, VFD_CLEAR, 2);
    usleep(50000);  // 50ms delay
    vfd->current_row = 0;
    vfd->current_col = 0;
}

void vfd_write(VFD_Display* vfd, const char* text) {
    if (!vfd || !text) return;

    size_t len = strlen(text);
    size_t pos = 0;

    while (pos < len) {
        if (text[pos] == '\n') {
            // Handle newline with CR+LF
            write(vfd->fd, "\x0D\x0A", 2);
            vfd->current_col = 0;
            vfd->current_row++;
            if (vfd->current_row >= VFD_ROWS) {
                vfd->current_row = VFD_ROWS - 1;
            }
        } else {
            // Handle regular character
            write(vfd->fd, &text[pos], 1);
            vfd->current_col++;
            if (vfd->current_col >= VFD_COLS) {
                write(vfd->fd, "\x0D\x0A", 2);
                vfd->current_col = 0;
                vfd->current_row++;
                if (vfd->current_row >= VFD_ROWS) {
                    vfd->current_row = VFD_ROWS - 1;
                }
            }
        }
        pos++;
    }
}

char* vfd_read(VFD_Display* vfd) {
    if (!vfd) return NULL;

    // Send query command
    write(vfd->fd, VFD_QUERY, 2);
    usleep(50000);  // Wait 50ms for response

    // Allocate buffer for response
    // Maximum possible size plus extra room for any control characters
    char* buffer = malloc(VFD_ROWS * VFD_COLS + 10);
    if (!buffer) return NULL;

    // Read response with timeout
    int total_read = 0;
    int attempts = 0;
    const int max_attempts = 10;

    // Keep reading until we timeout
    while (attempts < max_attempts) {
        int bytes = read(vfd->fd, buffer + total_read,
                        (VFD_ROWS * VFD_COLS + 10) - total_read);
        if (bytes > 0) {
            total_read += bytes;
            attempts = 0;  // Reset attempts if we got data
        } else {
            usleep(10000);  // Wait 10ms before next attempt
            attempts++;
        }
    }

    if (total_read == 0) {
        free(buffer);
        return NULL;
    }

    // Add null terminator after whatever we received
    buffer[total_read] = '\0';

    return buffer;
}




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_display.h
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//===============================
// FILE: vfd_display.h
//===============================
#ifndef VFD_DISPLAY_H
#define VFD_DISPLAY_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <termios.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/serial.h>

#define VFD_ROWS 6
#define VFD_COLS 40
#define VFD_CLEAR "\x19\x0C"
#define VFD_HOME "\x19\x0E"
#define VFD_BLINK_START "\x0B"
#define VFD_BLINK_END "\x0C"
#define VFD_BRIGHT "\x19\x4F"
#define VFD_SCROLL "\x10"
#define VFD_NEWLINE "\x0D\x0A"
#define VFD_CURSOR_UP "\x19\x0B"
#define VFD_CURSOR_POS "\x19\x11"
#define VFD_QUERY "\x04\x00"

typedef struct {
    int fd;
    struct termios old_tio;
    struct termios new_tio;
    int current_row;
    int current_col;
} VFD_Display;

// Function declarations
VFD_Display* vfd_init(const char* port);
void vfd_close(VFD_Display* vfd);
void vfd_clear(VFD_Display* vfd);
void vfd_write(VFD_Display* vfd, const char* text);
char* vfd_read(VFD_Display* vfd);

#endif




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_gpio.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//===============================
// FILE: vfd_gpio.c
//===============================
#include "vfd_gpio.h"
#include <unistd.h>  // For usleep

// Global pointer for callback access
static GPIO_Control* g_gpio_control = NULL;

GPIO_Control* gpio_init(void) {
    GPIO_Control* gpio = malloc(sizeof(GPIO_Control));
    if (!gpio) return NULL;

    // Store global reference for callback
    g_gpio_control = gpio;

    // Initialize pigpio without daemon
    gpioCfgSetInternals(1<<10);  // Configure for non-daemon operation
    if (gpioInitialise() < 0) {
        free(gpio);
        return NULL;
    }

    // Initialize button pin (GPIO 22 = Physical pin 16)
    gpioSetMode(MODE_BUTTON_PIN, PI_INPUT);
    gpioSetPullUpDown(MODE_BUTTON_PIN, PI_PUD_DOWN);  // Changed to pull-down for active high
    
    // Initialize NeoPixel
    memset(&gpio->ws2811, 0, sizeof(ws2811_t));
    gpio->ws2811.freq = LED_FREQ;
    gpio->ws2811.dmanum = LED_DMA;
    gpio->ws2811.channel[0].gpionum = NEOPIXEL_PIN;
    gpio->ws2811.channel[0].count = LED_COUNT;
    gpio->ws2811.channel[0].invert = LED_INVERT;
    gpio->ws2811.channel[0].brightness = 128;
    gpio->ws2811.channel[0].strip_type = LED_STRIP;

    if (ws2811_init(&gpio->ws2811) != WS2811_SUCCESS) {
        gpioTerminate();
        free(gpio);
        return NULL;
    }

    gpio->current_mode = MODE_SSH;
    gpio->button_debounce = 0;
    gpio->mode_changed = 0;

    // Set up GPIO monitoring for button
    gpioSetAlertFunc(MODE_BUTTON_PIN, button_callback);
    gpioSetISRFunc(MODE_BUTTON_PIN, RISING_EDGE, 0, button_callback);  // Changed to RISING_EDGE

    // Initial NeoPixel update
    update_neopixel_mode(gpio);
    
    return gpio;
}

void gpio_cleanup(GPIO_Control* gpio) {
    if (!gpio) return;
    
    // Clear NeoPixels
    for (int i = 0; i < LED_COUNT; i++) {
        gpio->ws2811.channel[0].leds[i] = COLOR_OFF;
    }
    ws2811_render(&gpio->ws2811);
    ws2811_fini(&gpio->ws2811);
    
    // Cleanup GPIO
    gpioSetMode(MODE_BUTTON_PIN, PI_INPUT);
    gpioSetPullUpDown(MODE_BUTTON_PIN, PI_PUD_DOWN);  // Keep pull-down on cleanup
    gpioTerminate();
    
    g_gpio_control = NULL;
    free(gpio);
}

void update_neopixel_mode(GPIO_Control* gpio) {
    if (!gpio) return;

    uint32_t color;
    switch (gpio->current_mode) {
        case MODE_SSH:
            color = COLOR_SSH;
            break;
        case MODE_LOCAL_KB:
            color = COLOR_LOCAL;
            break;
        case MODE_AUTO:
            color = COLOR_AUTO;
            break;
        default:
            color = COLOR_OFF;
            break;
    }

    // Update all LEDs to show current mode
    for (int i = 0; i < LED_COUNT; i++) {
        gpio->ws2811.channel[0].leds[i] = color;
    }
    ws2811_render(&gpio->ws2811);
}

void button_callback(int gpio, int level, uint32_t tick) {
    if (!g_gpio_control) return;
    
    // Simple debounce
    if (tick - g_gpio_control->button_debounce < 200000) return; // 200ms debounce
    g_gpio_control->button_debounce = tick;
    
    if (level == 1) { // Button pressed (active high)
        g_gpio_control->current_mode = (g_gpio_control->current_mode + 1) % MODE_COUNT;
        g_gpio_control->mode_changed = 1;
        update_neopixel_mode(g_gpio_control);
    }
}

const char* get_mode_name(VFD_Mode mode) {
    switch (mode) {
        case MODE_SSH:
            return "SSH Keyboard Input";
        case MODE_LOCAL_KB:
            return "Local Keyboard Input";
        case MODE_AUTO:
            return "Automatic Display";
        default:
            return "Unknown Mode";
    }
}

void show_mode_instructions(VFD_Display* vfd, VFD_Mode mode) {
    if (!vfd) return;
    
    vfd_clear(vfd);
    
    char buffer[128];
    snprintf(buffer, sizeof(buffer), "Mode: %s\n", get_mode_name(mode));
    vfd_write(vfd, buffer);
    
    switch (mode) {
        case MODE_SSH:
            vfd_write(vfd, "SSH keyboard input active\n");
            vfd_write(vfd, "Use terminal to type\n");
            break;
            
        case MODE_LOCAL_KB:
            vfd_write(vfd, "Local keyboard input active\n");
            vfd_write(vfd, "Connect USB keyboard to use\n");
            break;
            
        case MODE_AUTO:
            vfd_write(vfd, "Auto display mode active\n");
            vfd_write(vfd, "Messages will display automatically\n");
            break;
    }
    
    // Brief delay to show instructions
    usleep(2000000); // 2 second delay
    vfd_clear(vfd);
}




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_gpio.h
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//===============================
// FILE: vfd_gpio.h
//===============================
#ifndef VFD_GPIO_H
#define VFD_GPIO_H

#include <pigpio.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <ws2811.h>
#include "vfd_display.h"

#define MODE_BUTTON_PIN 22    // Physical pin 16, active high
#define NEOPIXEL_PIN 18      // Physical pin 12 (GPIO 18)
#define LED_COUNT 12         // 12-LED NeoPixel ring

// NeoPixel configuration
#define LED_FREQ     800000  // LED frequency
#define LED_DMA      10      // DMA channel
#define LED_INVERT   0       // Don't invert signal
#define LED_CHANNEL  0       // PWM channel
#define LED_STRIP    WS2811_STRIP_GRB

typedef enum {
    MODE_SSH = 0,
    MODE_LOCAL_KB = 1,
    MODE_AUTO = 2,
    MODE_COUNT
} VFD_Mode;

typedef struct {
    ws2811_t ws2811;
    VFD_Mode current_mode;
    int button_debounce;
    volatile int mode_changed;
} GPIO_Control;

// Color definitions for NeoPixel
#define COLOR_SSH    0x00FF00    // Green
#define COLOR_LOCAL  0x0000FF    // Blue
#define COLOR_AUTO   0xFF0000    // Red
#define COLOR_OFF    0x000000    // Off

// Function declarations
GPIO_Control* gpio_init(void);
void gpio_cleanup(GPIO_Control* gpio);
void update_neopixel_mode(GPIO_Control* gpio);
void button_callback(int gpio, int level, uint32_t tick);
const char* get_mode_name(VFD_Mode mode);
void show_mode_instructions(VFD_Display* vfd, VFD_Mode mode);

#endif




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_keyboard.h
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//===============================
// FILE: vfd_keyboard.h
//===============================
#ifndef VFD_KEYBOARD_H
#define VFD_KEYBOARD_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>

// Terminal settings
struct termios orig_termios;
int is_local_tty = 0;

// Check if we're on a local terminal
int check_local_terminal() {
    char *tty_name = ttyname(STDIN_FILENO);
    if (tty_name && strncmp(tty_name, "/dev/tty", 8) == 0) {
        return 1;  // Local terminal
    }
    return 0;  // SSH or other connection
}

// Initialize raw mode for keyboard input
void keyboard_raw_mode() {
    is_local_tty = check_local_terminal();

    // If local terminal, we need to handle keyboard differently
    if (is_local_tty) {
        system("chvt 1");  // Switch to tty1 if not already there
        system("clear");   // Clear the screen
    }

    tcgetattr(STDIN_FILENO, &orig_termios);
    struct termios raw = orig_termios;

    // Disable canonical mode and echo
    raw.c_lflag &= ~(ECHO | ICANON);

     // Allow Ctrl+C but disable other special character handling
    raw.c_lflag &= ~(IEXTEN | ICANON | ECHO);
    raw.c_lflag |= ISIG;  // Make sure ISIG is enabled

    // Disable flow control and other input processing
    raw.c_iflag &= ~(IXON | ICRNL);

    // Set character timeout
    raw.c_cc[VMIN] = 0;   // No minimum characters
    raw.c_cc[VTIME] = 1;  // 0.1 second timeout

    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

// Restore original terminal settings
void keyboard_restore() {
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
    if (is_local_tty) {
        printf("\033[?25h");  // Show cursor
        system("clear");      // Clear screen
    }
}

// Read a key, handling escape sequences
int read_key() {
    char c;
    if (read(STDIN_FILENO, &c, 1) != 1) return -1;

    if (c == 27) {  // ESC character
        char seq[3];

        if (read(STDIN_FILENO, &seq[0], 1) != 1) return 27;
        if (read(STDIN_FILENO, &seq[1], 1) != 1) return 27;

        if (seq[0] == '[') {
            switch (seq[1]) {
                case 'A': return 1001;  // Up arrow
                case 'B': return 1002;  // Down arrow
                case 'C': return 1003;  // Right arrow
                case 'D': return 1004;  // Left arrow
                case '3':  // Delete key
                    if (read(STDIN_FILENO, &seq[2], 1) != 1) return 27;
                    if (seq[2] == '~') return 1005;
            }
        }
    }

    return c;
}

#endif




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_mode_switch.c
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include "vfd_mode_switch.h"
#include <unistd.h>

Mode_Control* mode_init(void) {
    Mode_Control* ctrl = malloc(sizeof(Mode_Control));
    if (!ctrl) return NULL;

    ctrl->current_mode = MODE_SSH;
    ctrl->mode_changed = 0;
    return ctrl;
}

void mode_cleanup(Mode_Control* ctrl) {
    if (ctrl) free(ctrl);
}

const char* get_mode_name(VFD_Mode mode) {
    switch (mode) {
        case MODE_SSH:
            return "SSH Keyboard Input";
        case MODE_LOCAL_KB:
            return "Local Keyboard Input";
        case MODE_AUTO:
            return "Automatic Display";
        default:
            return "Unknown Mode";
    }
}

void show_mode_instructions(VFD_Display* vfd, VFD_Mode mode) {
    if (!vfd) return;
    
    vfd_clear(vfd);
    
    char buffer[128];
    snprintf(buffer, sizeof(buffer), "Mode: %s\n", get_mode_name(mode));
    vfd_write(vfd, buffer);
    
    vfd_write(vfd, "Press Ctrl+M to cycle modes\n");
    
    switch (mode) {
        case MODE_SSH:
            vfd_write(vfd, "SSH keyboard input active\n");
            vfd_write(vfd, "Use terminal to type\n");
            break;
            
        case MODE_LOCAL_KB:
            vfd_write(vfd, "Local keyboard input active\n");
            vfd_write(vfd, "Connect USB keyboard to use\n");
            break;
            
        case MODE_AUTO:
            vfd_write(vfd, "Auto display mode active\n");
            vfd_write(vfd, "Messages will display automatically\n");
            break;
    }
    
    usleep(2000000); // 2 second delay
    vfd_clear(vfd);
}




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# File: ./vfd_mode_switch.h
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifndef VFD_MODE_SWITCH_H
#define VFD_MODE_SWITCH_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "vfd_display.h"

typedef enum {
    MODE_SSH = 0,
    MODE_LOCAL_KB = 1,
    MODE_AUTO = 2,
    MODE_COUNT
} VFD_Mode;

typedef struct {
    VFD_Mode current_mode;
    volatile int mode_changed;
} Mode_Control;

Mode_Control* mode_init(void);
void mode_cleanup(Mode_Control* ctrl);
const char* get_mode_name(VFD_Mode mode);
void show_mode_instructions(VFD_Display* vfd, VFD_Mode mode);

#endif