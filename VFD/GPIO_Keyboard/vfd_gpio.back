//===============================
// FILE: vfd_gpio.c
//===============================
#include "vfd_gpio.h"

// Global pointer for callback access
static GPIO_Control* g_gpio_control = NULL;

GPIO_Control* gpio_init(void) {
    GPIO_Control* gpio = malloc(sizeof(GPIO_Control));
    if (!gpio) return NULL;

    // Store global reference for callback
    g_gpio_control = gpio;

    // Initialize pigpio without daemon
    gpioCfgSetInternals(1<<10);  // Configure for non-daemon operation
    if (gpioInitialise() < 0) {
        free(gpio);
        return NULL;
    }

    // Rest of initialization remains the same...

    // Initialize button pin
    gpioSetMode(MODE_BUTTON_PIN, PI_INPUT);
    gpioSetPullUpDown(MODE_BUTTON_PIN, PI_PUD_UP);

    // Initialize NeoPixel
    memset(&gpio->ws2811, 0, sizeof(ws2811_t));
    gpio->ws2811.freq = LED_FREQ;
    gpio->ws2811.dmanum = LED_DMA;
    gpio->ws2811.channel[0].gpionum = NEOPIXEL_PIN;
    gpio->ws2811.channel[0].count = LED_COUNT;
    gpio->ws2811.channel[0].invert = LED_INVERT;
    gpio->ws2811.channel[0].brightness = 128;
    gpio->ws2811.channel[0].strip_type = LED_STRIP;

    if (ws2811_init(&gpio->ws2811) != WS2811_SUCCESS) {
        gpioTerminate();
        free(gpio);
        return NULL;
    }

    gpio->current_mode = MODE_SSH;
    gpio->button_debounce = 0;
    gpio->mode_changed = 0;

    // Set up button callback
    gpioSetAlertFunc(MODE_BUTTON_PIN, button_callback);

    return gpio;
}

void gpio_cleanup(GPIO_Control* gpio) {
    if (!gpio) return;

    // Clear NeoPixels
    for (int i = 0; i < LED_COUNT; i++) {
        gpio->ws2811.channel[0].leds[i] = COLOR_OFF;
    }GPIO_Control* gpio_init(void) {
    GPIO_Control* gpio = malloc(sizeof(GPIO_Control));
    if (!gpio) return NULL;

    // Store global reference for callback
    g_gpio_control = gpio;

    // Initialize pigpio without daemon
    gpioCfgSetInternals(1<<10);  // Configure for non-daemon operation
    if (gpioInitialise() < 0) {
        free(gpio);
        return NULL;
    }

    // Rest of initialization remains the same...
    ws2811_render(&gpio->ws2811);
    ws2811_fini(&gpio->ws2811);

    // Cleanup GPIO
    gpioTerminate();
    g_gpio_control = NULL;
    free(gpio);
}

void update_neopixel_mode(GPIO_Control* gpio) {
    if (!gpio) return;

    uint32_t color;
    switch (gpio->current_mode) {
        case MODE_SSH:
            color = COLOR_SSH;
            break;
        case MODE_LOCAL_KB:
            color = COLOR_LOCAL;
            break;
        case MODE_AUTO:
            color = COLOR_AUTO;
            break;
        default:
            color = COLOR_OFF;
    }

    // Update all LEDs to show current mode
    for (int i = 0; i < LED_COUNT; i++) {
        gpio->ws2811.channel[0].leds[i] = color;
    }
    ws2811_render(&gpio->ws2811);
}

void button_callback(int gpio, int level, uint32_t tick) {
    if (!g_gpio_control) return;

    // Simple debounce
    if (tick - g_gpio_control->button_debounce < 200000) return; // 200ms debounce
    g_gpio_control->button_debounce = tick;

    if (level == 0) { // Button pressed (active low)
        g_gpio_control->current_mode = (g_gpio_control->current_mode + 1) % MODE_COUNT;
        g_gpio_control->mode_changed = 1;
        update_neopixel_mode(g_gpio_control);
    }
}

const char* get_mode_name(VFD_Mode mode) {
    switch (mode) {
        case MODE_SSH:
            return "SSH Keyboard Input";
        case MODE_LOCAL_KB:
            return "Local Keyboard Input";
        case MODE_AUTO:
            return "Automatic Display";
        default:
            return "Unknown Mode";
    }
}

void show_mode_instructions(VFD_Display* vfd, VFD_Mode mode) {
    if (!vfd) return;

    vfd_clear(vfd);

    char buffer[128];
    snprintf(buffer, sizeof(buffer), "Mode: %s\n", get_mode_name(mode));
    vfd_write(vfd, buffer);

    switch (mode) {
        case MODE_SSH:
            vfd_write(vfd, "SSH keyboard input active\n");
            vfd_write(vfd, "Use terminal to type\n");
            break;

        case MODE_LOCAL_KB:
            vfd_write(vfd, "Local keyboard input active\n");
            vfd_write(vfd, "Connect USB keyboard to use\n");
            break;

        case MODE_AUTO:
            vfd_write(vfd, "Auto display mode active\n");
            vfd_write(vfd, "Messages will display automatically\n");
            break;
    }

    // Brief delay to show instructions
    usleep(2000000); // 2 second delay
    vfd_clear(vfd);
}
